// ============================================================================
// NEON DATABASE SCHEMA V2 - PROPER VERSION
// ============================================================================
// Purpose: ALL Business Logic - Products, Inventory, Orders, Suppliers, Customers
// References Supabase via companyId (string) and createdById (string)
// ============================================================================

generator neonClient {
    provider        = "prisma-client-js"
    output          = "./generated/neon"
    previewFeatures = ["postgresqlExtensions"]
    binaryTargets   = ["native", "rhel-openssl-3.0.x"]
}

datasource neonDb {
    provider   = "postgresql"
    url        = env("NEON_DATABASE_URL")
    extensions = [pgvector]
}

// ============================================================================
// PRODUCT CATALOG
// ============================================================================

model Category {
    id           String  @id @default(uuid())
    companyId    String // ✅ Reference to Supabase Company.id
    name         String
    slug         String
    description  String?
    parentId     String?
    displayOrder Int     @default(0)
    icon         String?
    color        String?
    isActive     Boolean @default(true)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // ✅ PROPER RELATIONS
    parent   Category?  @relation("CategoryTree", fields: [parentId], references: [id], onDelete: Restrict)
    children Category[] @relation("CategoryTree")
    products Product[] // ✅ Back-relation to products!

    @@unique([companyId, slug])
    @@index([companyId, parentId])
    @@index([companyId, isActive])
    @@map("categories")
}

model Brand {
    id          String  @id @default(uuid())
    companyId   String // ✅ Reference to Supabase Company.id
    name        String
    slug        String
    description String?
    logo        String?
    website     String?
    isActive    Boolean @default(true)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // ✅ PROPER RELATIONS
    products Product[] // ✅ Back-relation to products!

    @@unique([companyId, slug])
    @@index([companyId, isActive])
    @@map("brands")
}

model Product {
    id         String  @id @default(uuid())
    companyId  String // ✅ Reference to Supabase Company.id
    categoryId String?
    brandId    String?

    // Basic info (NO redundant categoryName/brandName!)
    name        String
    sku         String
    barcode     String?
    description String?

    // ✅ Dimensions - Structured (NOT JSON!)
    lengthCm Decimal? @db.Decimal(10, 2)
    widthCm  Decimal? @db.Decimal(10, 2)
    heightCm Decimal? @db.Decimal(10, 2)
    weightKg Decimal? @db.Decimal(10, 3)

    // Pricing
    costPrice      Decimal? @db.Decimal(12, 2)
    sellingPrice   Decimal? @db.Decimal(12, 2)
    wholesalePrice Decimal? @db.Decimal(12, 2)

    // Inventory config (global defaults for all warehouses)
    minStock     Int @default(10)
    reorderPoint Int @default(50)

    // Product metadata
    status       ProductStatus @default(ACTIVE)
    isTrackable  Boolean       @default(true)
    isSerialized Boolean       @default(false)

    // Audit
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    createdById String // ✅ Reference to Supabase User.id

    // ✅ PROPER FOREIGN KEY RELATIONS (Not orphaned!)
    category Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
    brand    Brand?    @relation(fields: [brandId], references: [id], onDelete: SetNull)

    // Child relations
    variants         ProductVariant[]
    images           ProductImage[]
    tags             ProductTag[]
    inventoryItems   InventoryItem[] // ✅ For actual stock tracking
    supplierProducts ProductSupplier[]
    orderItems       OrderItem[]
    purchaseItems    PurchaseOrderItem[]
    productReviews   ProductReview[]

    @@unique([companyId, sku])
    @@index([companyId, status])
    @@index([companyId, categoryId])
    @@index([companyId, brandId])
    @@map("products")
}

model ProductVariant {
    id           String   @id @default(uuid())
    productId    String
    name         String
    sku          String
    barcode      String?
    costPrice    Decimal? @db.Decimal(12, 2)
    sellingPrice Decimal? @db.Decimal(12, 2)
    isActive     Boolean  @default(true)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    product        Product             @relation(fields: [productId], references: [id], onDelete: Cascade)
    attributes     VariantAttribute[]
    inventoryItems InventoryItem[]
    orderItems     OrderItem[]
    purchaseItems  PurchaseOrderItem[]

    @@unique([productId, sku])
    @@index([productId])
    @@map("product_variants")
}

// ✅ NO MORE JSON! Proper normalized attributes
model VariantAttribute {
    id        String @id @default(uuid())
    variantId String
    name      String // "color", "size", "material"
    value     String // "red", "Large", "cotton"

    variant ProductVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)

    @@unique([variantId, name])
    @@index([name, value])
    @@map("variant_attributes")
}

model ProductImage {
    id        String  @id @default(uuid())
    productId String
    url       String
    altText   String?
    order     Int     @default(0)
    isPrimary Boolean @default(false)

    product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

    @@index([productId, isPrimary])
    @@map("product_images")
}

model Tag {
    id        String @id @default(uuid())
    companyId String
    name      String
    slug      String

    products ProductTag[]

    @@unique([companyId, slug])
    @@map("tags")
}

model ProductTag {
    productId String
    tagId     String

    product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
    tag     Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

    @@id([productId, tagId])
    @@map("product_tags")
}

// ============================================================================
// WAREHOUSE & INVENTORY
// ============================================================================

model Warehouse {
    id          String  @id @default(uuid())
    companyId   String // ✅ Reference to Supabase Company.id
    name        String
    code        String
    description String?

    // ✅ Structured address (NO JSON!)
    address1   String?
    address2   String?
    city       String?
    state      String?
    postalCode String?
    country    String?

    // Coordinates for mapping
    latitude  Decimal? @db.Decimal(10, 8)
    longitude Decimal? @db.Decimal(11, 8)

    type     WarehouseType @default(STANDARD)
    isActive Boolean       @default(true)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    inventory InventoryItem[]

    @@unique([companyId, code])
    @@index([companyId, isActive])
    @@map("warehouses")
}

model InventoryItem {
    id          String  @id @default(uuid())
    productId   String
    variantId   String?
    warehouseId String

    // Location within warehouse
    zone  String?
    aisle String?
    shelf String?
    bin   String?

    // ✅ ACTUAL STOCK QUANTITIES (This is truth, not Product table!)
    quantity         Int @default(0)
    reservedQuantity Int @default(0)
    // ❌ NO availableQuantity field - it's computed as (quantity - reservedQuantity)

    // Lot/Batch tracking
    lotNumber   String?
    batchNumber String?
    expiryDate  DateTime?

    status InventoryStatus @default(AVAILABLE)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    product             Product              @relation(fields: [productId], references: [id], onDelete: Cascade)
    variant             ProductVariant?      @relation(fields: [variantId], references: [id], onDelete: Cascade)
    warehouse           Warehouse            @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
    movements           InventoryMovement[]
    stockReservations   StockReservation[]
    inventoryAuditItems InventoryAuditItem[]

    @@unique([productId, variantId, warehouseId, lotNumber])
    @@index([warehouseId, status])
    @@index([productId])
    @@map("inventory_items")
}

model InventoryMovement {
    id              String       @id @default(uuid())
    inventoryItemId String
    type            MovementType

    quantity       Int // Movement amount (+ve for in, -ve for out)
    quantityBefore Int // Audit trail
    quantityAfter  Int // Audit trail

    reason        String?
    referenceType String? // "ORDER", "PURCHASE", "ADJUSTMENT", "TRANSFER"
    referenceId   String? // ID of related record

    notes String?

    occurredAt  DateTime @default(now())
    createdById String // ✅ Reference to Supabase User.id

    inventoryItem InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

    @@index([inventoryItemId, occurredAt])
    @@index([referenceType, referenceId])
    @@map("inventory_movements")
}

// ============================================================================
// SUPPLIERS & PURCHASING
// ============================================================================

model Supplier {
    id        String  @id @default(uuid())
    companyId String // ✅ Reference to Supabase Company.id
    name      String
    code      String
    email     String?
    phone     String?
    website   String?

    // ✅ Structured address (NO JSON!)
    address1   String?
    address2   String?
    city       String?
    state      String?
    postalCode String?
    country    String?

    // Business info
    taxId        String?
    paymentTerms String?
    currency     String  @default("USD")

    status SupplierStatus @default(ACTIVE)

    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    createdById String // ✅ Reference to Supabase User.id

    productSuppliers ProductSupplier[]
    purchaseOrders   PurchaseOrder[]

    @@unique([companyId, code])
    @@index([companyId, status])
    @@map("suppliers")
}

model ProductSupplier {
    id         String @id @default(uuid())
    productId  String
    supplierId String

    // ❌ NO supplierName field! Get it from relation
    supplierSku  String?
    unitCost     Decimal @db.Decimal(12, 2)
    leadTimeDays Int?
    isPreferred  Boolean @default(false)

    product  Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
    supplier Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)

    @@unique([productId, supplierId])
    @@index([supplierId])
    @@map("product_suppliers")
}

model PurchaseOrder {
    id          String @id @default(uuid())
    companyId   String // ✅ Reference to Supabase Company.id
    orderNumber String
    supplierId  String

    subtotal     Decimal @db.Decimal(12, 2)
    taxAmount    Decimal @default(0) @db.Decimal(12, 2)
    shippingCost Decimal @default(0) @db.Decimal(12, 2)
    totalAmount  Decimal @db.Decimal(12, 2)

    status       PurchaseOrderStatus @default(DRAFT)
    orderDate    DateTime            @default(now())
    expectedDate DateTime?
    receivedDate DateTime?

    notes String?

    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    createdById String // ✅ Reference to Supabase User.id

    supplier Supplier            @relation(fields: [supplierId], references: [id], onDelete: Restrict)
    items    PurchaseOrderItem[]

    @@unique([companyId, orderNumber])
    @@index([companyId, status])
    @@index([supplierId])
    @@map("purchase_orders")
}

model PurchaseOrderItem {
    id              String  @id @default(uuid())
    purchaseOrderId String
    productId       String
    variantId       String?

    orderedQty  Int
    receivedQty Int     @default(0)
    unitCost    Decimal @db.Decimal(12, 2)
    totalCost   Decimal @db.Decimal(12, 2)

    notes String?

    purchaseOrder PurchaseOrder   @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
    product       Product         @relation(fields: [productId], references: [id], onDelete: Restrict)
    variant       ProductVariant? @relation(fields: [variantId], references: [id], onDelete: Restrict)

    @@index([purchaseOrderId])
    @@index([productId])
    @@map("purchase_order_items")
}

// ============================================================================
// CUSTOMERS & ORDERS
// ============================================================================

model Customer {
    id             String       @id @default(uuid())
    companyId      String // ✅ Reference to Supabase Company.id
    customerNumber String
    type           CustomerType @default(INDIVIDUAL)

    // For individuals
    firstName String?
    lastName  String?

    // For businesses
    businessName String?

    email String?
    phone String?

    // ✅ Structured billing address (NO JSON!)
    billingAddress1   String?
    billingAddress2   String?
    billingCity       String?
    billingState      String?
    billingPostalCode String?
    billingCountry    String?

    status CustomerStatus @default(ACTIVE)

    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    createdById String // ✅ Reference to Supabase User.id

    orders Order[]

    @@unique([companyId, customerNumber])
    @@index([companyId, status])
    @@index([email])
    @@map("customers")
}

model Order {
    id          String @id @default(uuid())
    companyId   String // ✅ Reference to Supabase Company.id
    orderNumber String
    customerId  String

    subtotal     Decimal @db.Decimal(12, 2)
    taxAmount    Decimal @default(0) @db.Decimal(12, 2)
    shippingCost Decimal @default(0) @db.Decimal(12, 2)
    totalAmount  Decimal @db.Decimal(12, 2)

    // ✅ Single status per concern (not triple status tracking)
    status        OrderStatus   @default(PENDING)
    paymentStatus PaymentStatus @default(PENDING)

    orderDate     DateTime  @default(now())
    shippedDate   DateTime?
    deliveredDate DateTime?

    notes String?

    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    createdById String // ✅ Reference to Supabase User.id

    customer Customer    @relation(fields: [customerId], references: [id], onDelete: Restrict)
    items    OrderItem[]

    @@unique([companyId, orderNumber])
    @@index([companyId, status])
    @@index([customerId])
    @@index([orderDate])
    @@map("orders")
}

model OrderItem {
    id        String  @id @default(uuid())
    orderId   String
    productId String
    variantId String?

    orderedQty Int
    shippedQty Int     @default(0)
    unitPrice  Decimal @db.Decimal(12, 2)
    totalPrice Decimal @db.Decimal(12, 2)

    notes String?

    order   Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
    product Product         @relation(fields: [productId], references: [id], onDelete: Restrict)
    variant ProductVariant? @relation(fields: [variantId], references: [id], onDelete: Restrict)

    @@index([orderId])
    @@index([productId])
    @@map("order_items")
}

// ============================================================================
// ADDITIONAL TABLES - ADD TO NEON SCHEMA
// ============================================================================

// 1. STOCK RESERVATION - Reserve inventory for orders
model StockReservation {
    id              String @id @default(uuid())
    inventoryItemId String
    productId       String // Denormalized for quick lookup
    warehouseId     String // Denormalized for quick lookup

    // Reservation details
    quantity    Int
    reservedFor String // "ORDER", "TRANSFER", "MANUAL"
    referenceId String? // Order ID, Transfer ID, etc.

    // Status & lifecycle
    status    ReservationStatus @default(ACTIVE)
    expiresAt DateTime? // Auto-release if not fulfilled

    // Notes
    reason String?
    notes  String?

    // Audit
    createdAt    DateTime  @default(now())
    createdById  String
    releasedAt   DateTime?
    releasedById String?

    // ✅ PROPER RELATIONS
    inventoryItem InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

    @@index([inventoryItemId, status])
    @@index([productId, warehouseId])
    @@index([referenceId])
    @@index([expiresAt])
    @@map("stock_reservations")
}

enum ReservationStatus {
    ACTIVE // Currently reserved
    FULFILLED // Released and used
    CANCELLED // Cancelled/released early
    EXPIRED // Auto-expired
}

// ============================================================================

// 2. INVENTORY AUDIT - Cycle counting and physical verification
model InventoryAudit {
    id          String  @id @default(uuid())
    companyId   String
    warehouseId String? // NULL = all warehouses

    // Audit info
    auditNumber String
    auditType   AuditType
    method      AuditMethod

    // Dates
    plannedDate DateTime
    startedAt   DateTime?
    completedAt DateTime?

    // Status
    status AuditStatus @default(PLANNED)

    // Results
    itemsPlanned  Int @default(0)
    itemsCounted  Int @default(0)
    discrepancies Int @default(0)

    // Notes
    notes String?

    // Audit team
    createdAt   DateTime  @default(now())
    createdById String
    conductedBy String?
    approvedBy  String?
    approvedAt  DateTime?

    // ✅ PROPER RELATIONS
    items InventoryAuditItem[]

    @@unique([companyId, auditNumber])
    @@index([companyId, status])
    @@index([warehouseId])
    @@map("inventory_audits")
}

model InventoryAuditItem {
    id              String @id @default(uuid())
    auditId         String
    inventoryItemId String
    productId       String // Denormalized for reporting
    warehouseId     String // Denormalized for reporting

    // Expected vs Actual
    expectedQuantity Int
    countedQuantity  Int?
    variance         Int? // countedQuantity - expectedQuantity

    // Status
    status                AuditItemStatus @default(PENDING)
    requiresInvestigation Boolean         @default(false)

    // Details
    lotNumber         String?
    notes             String?
    discrepancyReason String?

    // Audit trail
    countedAt    DateTime?
    countedById  String?
    verifiedAt   DateTime?
    verifiedById String?
    adjustedAt   DateTime?
    adjustedById String?

    // ✅ PROPER RELATIONS
    audit         InventoryAudit @relation(fields: [auditId], references: [id], onDelete: Cascade)
    inventoryItem InventoryItem  @relation(fields: [inventoryItemId], references: [id], onDelete: Restrict)

    @@index([auditId])
    @@index([inventoryItemId])
    @@index([status])
    @@map("inventory_audit_items")
}

enum AuditType {
    CYCLE_COUNT // Regular cycle counting
    FULL_COUNT // Complete physical count
    SPOT_CHECK // Random verification
    YEAR_END // Annual inventory count
    INVESTIGATION // Due to discrepancy
}

enum AuditMethod {
    MANUAL // Paper-based counting
    BARCODE // Barcode scanning
    RFID // RFID tracking
    ABC_ANALYSIS // Focus on high-value items
}

enum AuditStatus {
    PLANNED
    IN_PROGRESS
    REVIEW
    COMPLETED
    CANCELLED
}

enum AuditItemStatus {
    PENDING // Not counted yet
    COUNTED // Counted, awaiting verification
    VERIFIED // Count verified
    ADJUSTED // Inventory adjusted
    EXCEPTION // Needs investigation
}

// ============================================================================

// 3. PRODUCT REVIEW - Customer reviews and ratings
model ProductReview {
    id        String @id @default(uuid())
    productId String
    companyId String // For multi-tenant filtering

    // Review content
    rating Int // 1-5 stars
    title  String?
    review String?

    // Reviewer info
    reviewerName  String?
    reviewerEmail String?
    userId        String? // If logged-in user
    customerId    String? // Link to customer if available

    // Verification
    isVerifiedPurchase Boolean   @default(false)
    purchaseDate       DateTime?

    // Moderation
    isApproved Boolean @default(false)
    isVisible  Boolean @default(true)
    isFlagged  Boolean @default(false)
    flagReason String?

    // Helpfulness
    helpfulVotes    Int @default(0)
    notHelpfulVotes Int @default(0)

    // Dates
    createdAt    DateTime  @default(now())
    updatedAt    DateTime  @updatedAt
    approvedAt   DateTime?
    approvedById String?

    // ✅ PROPER RELATIONS
    product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

    @@index([productId, isVisible])
    @@index([companyId])
    @@index([rating])
    @@index([createdAt])
    @@map("product_reviews")
}

// ============================================================================

// 4. RAG DOCUMENT - AI/Semantic search embeddings
model RagDocument {
    id        String @id @default(uuid())
    companyId String // Multi-tenant isolation

    // Source info
    source     String // "product:123", "order:456"
    sourceType String // "product", "order", "supplier"
    sourceId   String // ID of source record

    // Content
    chunkIndex Int // For splitting large docs
    content    String  @db.Text
    title      String?

    // Embedding
    embedding Unsupported("vector(1536)") // OpenAI ada-002 dimensions

    // Metadata
    metadata Json? // Flexible metadata

    // Versioning
    version   Int     @default(1)
    isLatest  Boolean @default(true)
    isDeleted Boolean @default(false)

    // Dates
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([companyId, source, chunkIndex, version])
    @@index([companyId, sourceType, isLatest])
    @@index([companyId, isDeleted])
    // For vector similarity search (requires pgvector extension):
    // @@index([embedding], type: Hnsw, ops: VectorCosineOps)
    @@map("rag_documents")
}

// ============================================================================
// ENUMS
// ============================================================================

enum ProductStatus {
    ACTIVE
    INACTIVE
    DISCONTINUED
    DRAFT
}

enum WarehouseType {
    STANDARD
    DISTRIBUTION_CENTER
    RETAIL_STORE
    COLD_STORAGE
    FULFILLMENT_CENTER
}

enum InventoryStatus {
    AVAILABLE
    RESERVED
    QUARANTINE
    DAMAGED
    EXPIRED
}

enum MovementType {
    RECEIPT // Receiving stock
    SHIPMENT // Shipping out
    ADJUSTMENT // Manual adjustment
    TRANSFER_OUT // Transfer to another warehouse
    TRANSFER_IN // Transfer from another warehouse
    RETURN // Customer return
    DAMAGE // Damage/loss
}

enum SupplierStatus {
    ACTIVE
    INACTIVE
    SUSPENDED
}

enum PurchaseOrderStatus {
    DRAFT
    PENDING
    APPROVED
    PARTIALLY_RECEIVED
    RECEIVED
    CANCELLED
}

enum CustomerType {
    INDIVIDUAL
    BUSINESS
}

enum CustomerStatus {
    ACTIVE
    INACTIVE
    PROSPECT
    SUSPENDED
}

enum OrderStatus {
    PENDING
    CONFIRMED
    PROCESSING
    SHIPPED
    DELIVERED
    CANCELLED
    RETURNED
}

enum PaymentStatus {
    PENDING
    PAID
    PARTIALLY_PAID
    FAILED
    REFUNDED
}
